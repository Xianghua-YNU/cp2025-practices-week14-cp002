# 受驱单摆的非线性动力学实验报告

## 1. 实验目的

简要描述本实验的主要目标：
1. 实现并比较不同数值方法求解受驱单摆方程的效果
2. 研究受驱单摆系统的共振现象
3. 分析系统在不同参数下的混沌行为

## 2. 理论背景

### 2.1 受驱单摆方程

简要介绍受驱单摆的运动方程及其物理意义：
- 方程的推导过程
- 各项参数的物理含义
- 无量纲化处理（如果使用）

### 2.2 数值方法

简要说明使用的数值方法原理：
1. 欧拉法
   - 基本原理:对于一阶常微分方程 \frac{dy}{dt}=f(t,y)，已知初始条件 y(t_0)=y_0。欧拉法的基本思想是使用当前点的斜率（即 f(t_n,y_n)）来近似下一个点的函数值。通过迭代公式 y_{n + 1} = y_n + hf(t_n,y_n) 来逐步求解，其中 h = t_{n+1}-t_n 是时间步长，t_{n+1}=t_n + h。对于高阶常微分方程，可以转化为一阶常微分方程组来求解。
   - 误差阶数:局部截断误差为 O(h^2)，全局截断误差为 O(h)，其中 h 是时间步长。
   - 优缺点:算法简单，计算量小，易于理解和实现。精度较低，随着时间推进，误差积累较快，对步长 h 比较敏感，步长较大时结果可能严重偏离真实值。

2. 改进欧拉法
   - 改进的思路:简单欧拉法只使用了起点处的斜率，改进欧拉法对其进行了修正。它采用了预测-校正的思想，先使用欧拉法进行预测，得到 \tilde{y}_{n+1}=y_n + hf(t_n,y_n)；然后计算区间端点处的斜率 f(t_{n + 1},\tilde{y}_{n+1})，再对预测值进行校正，得到 y_{n + 1} = y_n + \frac{h}{2}[f(t_n,y_n)+f(t_{n + 1},\tilde{y}_{n+1})]。这样综合考虑了区间两端的斜率，提高了精度。
   - 误差阶数:局部截断误差为 O(h^3)，全局截断误差为 O(h^2)，相比简单欧拉法，精度有所提高。

   - 与简单欧拉法的比较：改进欧拉法的精度高于简单欧拉法，因为它考虑了区间两端的斜率，能更好地逼近真实解。

3. 四阶龙格-库塔法
   - 方法原理：四阶龙格-库塔法是一种基于加权平均斜率的数值方法。对于 \frac{dy}{dt}=f(t,y)，在区间 [t_n,t_{n+1}] 上，通过计算四个不同点的斜率 k_1,k_2,k_3,k_4 并进行加权平均来确定下一个点的函数值。
   - 误差阶数：误差阶数：局部截断误差为 O(h^5)，全局截断误差为 O(h^4)，精度较高。
   - 计算效率分析:
每一步需要计算四次函数值，计算量相对较大。但由于其精度高，在求解一些对精度要求较高的问题时，相比低阶方法（如欧拉法），可以使用较大的步长仍能保持较好的精度，从整体计算量和计算时间上看，在很多情况下可能更具优势。在处理复杂的动力学系统（如洛伦兹系统）时，能够在合理的时间内给出较为可靠的数值解 。
## 3. 实验方法

### 3.1 代码实现

简要说明各个函数的实现思路：
1. `forced_pendulum_ode`函数
   - 实现要点:该函数的主要目的是定义受迫单摆的动力学方程，将二阶常微分方程转化为一阶常微分方程组的形式，以便后续使用数值方法进行求解。通常受迫单摆的运动方程会涉及到摆角、角速度、外力等参数。

   - 关键步骤说明:参数定义,方程转化

2. 数值求解方法
   - 欧拉法实现要点: 初始化：确定初始时间 t_0、初始状态 y_0（如摆角和角速度的初始值）、时间步长 h 和总时间 T。迭代求解：根据欧拉法的迭代公式 y_{n + 1} = y_n + hf(t_n,y_n)，在每个时间步长内，使用当前的状态和时间计算导数（通过调用 forced_pendulum_ode 函数），然后更新状态。存储结果：将每次迭代得到的时间和状态值存储起来，以便后续分析和绘图。
   - 改进欧拉法实现要点:初始化：与欧拉法类似，确定初始时间、初始状态、时间步长和总时间。预测步骤：使用欧拉法进行预测，得到 \tilde{y}_{n+1}=y_n + hf(t_n,y_n)。校正步骤：计算区间端点处的斜率 f(t_{n + 1},\tilde{y}_{n+1})，然后对预测值进行校正，得到 y_{n + 1} = y_n + \frac{h}{2}[f(t_n,y_n)+f(t_{n + 1},\tilde{y}_{n+1})]，这里需要两次调用 forced_pendulum_ode 函数。
   - RK4方法实现要点:初始化：确定初始时间、初始状态、时间步长和总时间。 计算斜率：在每个时间步长内，按照 RK4 方法的公式计算四个斜率 k_1,k_2,k_3,k_4，每次计算斜率都需要调用 forced_pendulum_ode 函数。更新状态：根据 y_{n + 1} = y_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4) 更新状态。存储结果：将时间和状态值记录下来，用于后续处理。

### 3.2 实验参数

列出实验中使用的主要参数：
- 阻尼系数 γ
- 驱动频率 ω_d
- 驱动力幅度 F_d
- 初始条件
- 时间步长
- 其他相关参数

## 4. 实验结果与分析

### 4.1 数值方法比较

1. 不同方法的数值解比较
   - 插入时间序列图
   - <img width="709" alt="919b251070251558c9e6474e97c8530" src="https://github.com/user-attachments/assets/3383f930-70dc-4af9-b6c4-ebb556b514e1" />

   - 分析三种方法的计算结果差异:欧拉法：由于欧拉法局部截断误差为 O(h^2)，全局截断误差为 O(h) ，精度相对较低。：改进欧拉法采用预测 - 校正思路，局部截断误差为 O(h^3)，全局截断误差为 O(h^2) ，精度比欧拉法有所提高。四阶龙格 - 库塔法局部截断误差为 O(h^5)，全局截断误差为 O(h^4) ，精度较高。其计算结果能够较为准确地呈现受迫单摆的运动，在图中对应的曲线应该最接近受迫单摆的真实运动轨迹
   - 讨论数值稳定性: 欧拉法：稳定性较差，改进欧拉法：稳定性优于欧拉法，预测 - 校正机制在一定程度上改善了数值稳定性，四阶龙格 - 库塔法：在合理的步长范围内具有较好的数值稳定性，能够处理多种类型的常微分方程问题。

2. 计算效率比较
   - 比较不同方法的计算时间:欧拉法：计算量最小，每一步只需要计算一次函数值（即单摆动力学方程的导数），算法简单，执行速度相对较快。改进欧拉法：每一步需要计算两次函数值（预测和校正各一次），计算量比欧拉法有所增加，执行速度相对较慢。四阶龙格 - 库塔法：每一步需要计算四次函数值，计算量最大，执行速度相对较慢。
   - 分析精度和效率的权衡；欧拉法：适用于对精度要求不高、初步探索性的计算，或者计算资源有限且只需要大致结果的情况。改进欧拉法：在精度和效率之间提供了一种折中的选择。 四阶龙格 - 库塔法：当对计算精度要求较高，例如需要精确分析受迫单摆的长期运动特性、研究其混沌行为等场景下，尽管计算效率相对较低（每步计算量较大），但凭借其高精度优势，能够给出可靠的结果。

### 4.2 共振现象分析

1. 共振曲线
   - 插入幅频特性图
   - <img width="699" alt="54ab80e69708a1cd1373c704e867e79" src="https://github.com/user-attachments/assets/53af5cad-c87f-42ef-8422-e157dd8b7b64" />

   - 分析共振频率：从图中可以看出，蓝色曲线（振幅随驱动频率的变化）出现峰值的位置对应的驱动频率即为共振频率。图中该峰值对应的驱动频率约为 10 rad/s，这意味着当外界驱动力的频率接近此值时，受迫振动系统的振幅达到最大 ，此时系统发生共振。

   - 讨论阻尼对共振的影响：阻尼减小共振振幅：在存在阻尼的实际系统中，阻尼会消耗系统的能量。当阻尼增大时，共振峰值会降低，即共振时的最大振幅会减小。因为阻尼会阻碍系统的振动，使得振动能量在不断的耗散中难以积累到很高的水平。在本图中，若进一步增大阻尼，理论上该蓝色曲线的峰值会进一步下降。


2. 特征分析
   - 描述观察到的共振特征：图中最明显的特征是存在一个尖锐的峰值，这清晰地表明了系统存在共振现象。峰值越高，说明在共振频率下系统振幅越大，能量的积累效应越明显。在共振频率左侧，随着驱动频率的增加，振幅逐渐增大，表明系统逐渐接近共振状态；在共振频率右侧，随着驱动频率的继续增加，振幅迅速减小，说明系统逐渐远离共振状态，驱动力频率与系统固有频率的失配程度增大，导致振幅难以维持在较高水平。
   - 与理论预期的比较：说明实际观察结果与理论预期相符。


### 4.3 混沌行为研究

1. 相空间分析
   - 插入相空间图
   - <img width="716" alt="7ae78e6c0d58c5e1aa9f51bbcfce41d" src="https://github.com/user-attachments/assets/5293aa87-3dd8-47be-8d25-d7aa5705883f" />

   - 描述轨道特征：在一定时间间隔内，摆角的变化模式重复出现，振幅在特定范围内波动，整体上没有表现出混沌系统中那种不规则、对初始条件极度敏感的特征 ，表明此时系统处于较为规则的受迫振动状态。

   - 分析混沌的产生条件：非线性因素：受迫单摆系统本身具有非线性。外部激励：合适的外部激励频率和强度是混沌产生的重要条件。阻尼作用：阻尼会耗散系统能量。

2. 参数依赖性
   - 不同参数下的系统行为：当驱动频率接近系统固有频率时，系统容易出现共振，此时振幅增大。驱动振幅较小时，系统一般保持规则运动。阻尼系数影响系统能量耗散
   - 混沌转捩的特征：轨道变化：从规则的周期性轨道逐渐变为不规则、不重复的轨道。原本清晰的周期性摆动模式被打破，摆角的变化不再有固定的周期和模式。
对初始条件敏感性增加：在混沌转捩过程中，系统对初始条件变得极为敏感，初始条件的微小差异会导致系统在长时间后的行为产生巨大差异，即“蝴蝶效应”开始显现。
功率谱变化：在频谱分析中，规则运动时功率谱表现为离散的峰值，对应于系统的固有频率和驱动频率及其谐波；而在混沌转捩后，功率谱会逐渐变为连续谱，表明系统的运动包含了更广泛的频率成分 。

## 5. 讨论

1. 数值方法的适用性
   - 各方法的优缺点：欧拉法虽然实现简单、计算速度快，但其一阶精度导致长期模拟时误差积累严重，特别是在非线性较强的系统中容易产生明显的能量漂移。改进欧拉法通过引入预测-校正步骤，将精度提升至二阶，显著改善了稳定性，但对于高精度需求仍然不足。四阶龙格-库塔法凭借其高阶精度和良好的稳定性，能够准确捕捉系统的非线性行为和长期演化特性，尽管计算成本较高，但在研究混沌和共振现象时是不可替代的最佳选择。
   - 最佳方法的选择建议：对于受迫摆这类非线性系统，若仅需短期定性分析，改进欧拉法是一个平衡效率与精度的折中方案；但若需精确研究混沌或共振行为，必须采用四阶龙格-库塔法，并配合适当的步长控制策略。


2. 物理现象的解释
   - 共振机理：在受迫摆系统中表现为当驱动力频率接近系统固有频率时，摆角振幅显著增大。这一现象源于能量输入的周期性匹配，导致系统持续吸收外部能量。然而，非线性项（如sinθ）的存在使得共振行为更加复杂，可能出现倍周期分岔等非线性响应。
   - 混沌产生的机制：在特定参数范围内（如驱动力幅值或频率的某些区间），受迫摆的运动轨迹会表现出对初值的极端敏感性，即微小的初始差异随时间呈指数增长，最终导致完全不可预测的行为。这种确定性混沌揭示了即使完全确定的方程也可能产生看似随机的动力学行为。
   - 与其他物理系统的类比:受迫摆与约瑟夫森结、带电粒子在电磁场中的运动等系统具有相似的动力学方程，均表现出共振、分岔和混沌等丰富现象。这些系统的共性在于非线性与周期驱动的耦合，为研究复杂动力学提供了普适的模型框架。

3. 实验中遇到的问题和解决方法
   - 数值计算中的困难:长期模拟时的误差积累和混沌系统对步长的敏感性。例如，使用欧拉法时，即使很小的步长也可能因截断误差导致能量不守恒，从而掩盖真实的物理行为。解决方法是通过收敛性测试，确保步长足够小（如RK4方法中dt=0.01），或采用自适应步长算法动态调整精度。
   - 参数选择的考虑:参数选择需特别注意驱动力幅值、频率和阻尼系数的组合。
   - 改进建议:引入更高效的算法（如辛算法用于保守系统），或结合庞加莱截面等工具可视化混沌吸引子。此外，并行计算可加速参数空间的探索，尤其是在研究分岔图时。


## 6. 结论

总结实验的主要发现：
1. 数值方法的比较结果:四阶龙格-库塔法在精度和稳定性上显著优于欧拉法及其改进版本，是非线性系统研究的首选方法。改进欧拉法可作为快速验证的辅助工具，而原生欧拉法仅适用于教学演示。

2. 受驱单摆的动力学特征:包括周期运动、倍周期分岔和混沌状态。其行为强烈依赖于驱动频率和振幅，在参数空间中存在清晰的共振峰和混沌带。
3. 共振和混沌现象的主要特点:共振现象表现为能量输入的高效吸收，而混沌的产生则源于非线性与初值敏感性的协同作用。这些现象不仅揭示了确定性系统中的内在复杂性，也为理解更广泛的物理系统（如等离子体波动、量子输运等）提供了理论基础。实验还表明，数值方法的合理选择对正确揭示这些特性至关重要。

## 7. 参考文献

列出参考的文献资料：
1. 教材和参考书
2. 相关论文
3. 网络资源

## 附录：核心代码

附上关键函数的代码实现（建议只包含最核心的部分）：

```python
# 在此粘贴核心代码
def forced_pendulum_ode(t, state, l, g, C, Omega):
    theta, omega = state
    dtheta_dt = omega
    domega_dt = -(g/l)*np.sin(theta) + C*np.cos(theta)*np.sin(Omega*t)
    return [dtheta_dt, domega_dt]
sol = solve_ivp(
    lambda t, y: forced_pendulum_ode(t, y, l, g, C, Omega),
    t_span,
    y0,
    t_eval=t_eval,
    rtol=1e-6,
    atol=1e-9
)
```
